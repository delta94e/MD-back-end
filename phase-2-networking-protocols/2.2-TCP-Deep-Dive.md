# 2.2 TCP Deep Dive — Transmission Control Protocol

> **Mục tiêu:** Hiểu THẬT SÂU TCP — không chỉ "reliable protocol" mà còn TẠI SAO nó reliable, CƠ CHẾ nào đảm bảo, và ĐÁNH ĐỔI gì để có được reliability đó.
>
> **Ngôn ngữ:** Go | **Phương pháp:** 6 Analysis Patterns | **Đối tượng:** Backend Engineer hướng Senior

---

## Bản Đồ Tổng Quan — Mental Map

```
╔═══════════════════════════════════════════════════════════════════════════╗
║   TCP — BẢN ĐỒ KIẾN THỨC TOÀN DIỆN                                    ║
╠═══════════════════════════════════════════════════════════════════════════╣
║                                                                           ║
║  ┌─────────────────────────────────────────────────────────────────────┐ ║
║  │                    APPLICATION LAYER                                │ ║
║  │  HTTP │ gRPC │ WebSocket │ Database Protocol │ SMTP │ FTP          │ ║
║  │  "Tôi muốn gửi data, đảm bảo đến nơi, đúng thứ tự!"            │ ║
║  └───────────────────────────┬─────────────────────────────────────────┘ ║
║                              │ send(data)                                ║
║                              ▼                                           ║
║  ┌─────────────────────────────────────────────────────────────────────┐ ║
║  │                    TCP LAYER (Transport)                            │ ║
║  │                                                                     │ ║
║  │  ┌──────────┐  ┌──────────┐  ┌──────────┐  ┌──────────────────┐  │ ║
║  │  │Connection│  │Reliability│  │  Flow    │  │   Congestion     │  │ ║
║  │  │Management│  │ Engine   │  │ Control  │  │   Control        │  │ ║
║  │  │          │  │          │  │          │  │                   │  │ ║
║  │  │3-way     │  │SEQ/ACK   │  │Sliding   │  │Slow Start        │  │ ║
║  │  │Handshake │  │Retransmit│  │Window    │  │Congestion Avoid  │  │ ║
║  │  │4-way     │  │Checksum  │  │Advertised│  │Fast Retransmit   │  │ ║
║  │  │Teardown  │  │Timeout   │  │Window    │  │Fast Recovery     │  │ ║
║  │  │TIME_WAIT │  │DupACK    │  │Zero Win  │  │CUBIC/BBR         │  │ ║
║  │  └──────────┘  └──────────┘  └──────────┘  └──────────────────┘  │ ║
║  │                                                                     │ ║
║  │  ┌──────────────────────────────────────┐                          │ ║
║  │  │        TCP HEADER (20-60 bytes)      │                          │ ║
║  │  │  Src Port │ Dst Port │ SEQ │ ACK    │                          │ ║
║  │  │  Flags │ Window │ Checksum │ Options│                          │ ║
║  │  └──────────────────────────────────────┘                          │ ║
║  └───────────────────────────┬─────────────────────────────────────────┘ ║
║                              │ IP packet                                 ║
║                              ▼                                           ║
║  ┌─────────────────────────────────────────────────────────────────────┐ ║
║  │                    IP LAYER (Network)                               │ ║
║  │  "Tôi chỉ gửi packet, không đảm bảo gì cả!" (best-effort)      │ ║
║  └─────────────────────────────────────────────────────────────────────┘ ║
║                                                                           ║
║  KEY INSIGHT:                                                            ║
║  TCP xây một hệ thống ĐÁNG TIN CẬY trên nền tảng KHÔNG TIN CẬY.     ║
║  Giống như xây nhà kiên cố trên nền đất không ổn định!                ║
║                                                                           ║
╚═══════════════════════════════════════════════════════════════════════════╝
```

---

## Contextual History — Tại Sao TCP Tồn Tại?

### Câu chuyện: Từ ARPANET đến Internet hiện đại

**Năm 1969 — ARPANET ra đời:**

Bộ Quốc phòng Mỹ (DARPA) muốn một mạng máy tính có thể **sống sót sau tấn công hạt nhân**. Yêu cầu: nếu một node bị phá hủy, traffic phải tự động tìm đường khác. Đây là lý do internet được thiết kế **phi tập trung** (decentralized) — không có "trung tâm" nào mà kẻ thù có thể tấn công.

**Vấn đề ban đầu:** ARPANET dùng NCP (Network Control Protocol) — một protocol đơn giản, hoạt động tốt trong mạng nhỏ. Nhưng khi mạng mở rộng:

```
NCP (1970s):
├── Chỉ hoạt động trong 1 mạng (ARPANET)
├── Không có error recovery
├── Không có flow control
├── Không thể kết nối giữa các mạng khác nhau
└── → CẦN protocol mới!

TCP/IP (1983 — "Flag Day"):
├── Tách thành 2 layer: TCP (reliability) + IP (routing)
├── Hoạt động GIỮA các mạng (inter-networking → Internet!)
├── Error recovery: retransmission, checksum
├── Flow control: sliding window
└── → Trở thành NỀN TẢNG của Internet!
```

**Ngày 1/1/1983 — "Flag Day":** Toàn bộ ARPANET chuyển từ NCP sang TCP/IP trong MỘT NGÀY. Đây là ngày sinh chính thức của Internet như chúng ta biết.

### Tại sao tách TCP và IP?

```
╔═══════════════════════════════════════════════════════════════╗
║   QUYẾT ĐỊNH THIẾT KẾ THEN CHỐT                              ║
╠═══════════════════════════════════════════════════════════════╣
║                                                               ║
║  Ban đầu: TCP và IP là MỘT protocol (TCP v1, v2, v3)       ║
║                                                               ║
║  Vint Cerf & Bob Kahn nhận ra:                               ║
║  → Routing (tìm đường) ≠ Reliability (đảm bảo đến nơi)  ║
║  → Có ứng dụng CẦN reliability (file transfer, email)      ║
║  → Có ứng dụng KHÔNG CẦN (voice, video — delay > loss)     ║
║                                                               ║
║  → TÁCH thành 2 protocols:                                   ║
║     IP  = routing only (best-effort, connectionless)        ║
║     TCP = reliability on top of IP (connected, ordered)      ║
║     UDP = lightweight alternative (connectionless, fast)     ║
║                                                               ║
║  Kết quả: Separation of Concerns ở tầng protocol!          ║
║  → Thêm protocol mới trên IP dễ dàng (QUIC, SCTP, DCCP)   ║
║  → Thay đổi routing không ảnh hưởng reliability            ║
║                                                               ║
║  💡 Đây là NGUYÊN TẮC thiết kế phần mềm:                   ║
║  Single Responsibility Principle — ở tầng NETWORK!          ║
║                                                               ║
╚═══════════════════════════════════════════════════════════════╝
```

### Dòng thời gian tiến hóa TCP

```
1974 ─── TCP v1 (Cerf & Kahn paper) — TCP + IP gộp chung
  │
1978 ─── TCP v3 → tách thành TCP + IP riêng biệt
  │
1981 ─── RFC 793: TCP specification chính thức
  │       → 3-way handshake, SEQ/ACK, sliding window
  │
1983 ─── "Flag Day" — ARPANET chuyển sang TCP/IP
  │
1986 ─── Internet "congestion collapse" — mạng tắc nghẽn!
  │       → Van Jacobson phát minh congestion control
  │
1988 ─── TCP Tahoe: Slow Start + Congestion Avoidance
  │
1990 ─── TCP Reno: Fast Retransmit + Fast Recovery
  │
1996 ─── RFC 2018: SACK (Selective ACK) — ACK chọn lọc
  │
2004 ─── TCP BIC → CUBIC (Linux default từ 2.6.19)
  │       → Optimized cho high-bandwidth, high-latency
  │
2016 ─── TCP BBR (Google) — Bottleneck Bandwidth & RTT
  │       → Model-based, không dựa trên packet loss
  │       → YouTube giảm 4% rebuffering toàn cầu!
  │
2020 ─── QUIC (HTTP/3) — "TCP 2.0" built on UDP
         → Giải quyết head-of-line blocking
         → 0-RTT connection setup
         → Nhưng... vẫn implement lại mọi thứ TCP đã làm!

💡 KEY INSIGHT:
QUIC chứng minh rằng TCP đã ĐÚNG về mặt concept.
QUIC chỉ fix CÁCH IMPLEMENT, không phải ý tưởng!
```

---

## 5 Whys: Tại Sao Cần TCP?

```
╔═══════════════════════════════════════════════════════════════╗
║   5 WHYS — TỪ HIỆN TƯỢNG ĐẾN BẢN CHẤT                      ║
╠═══════════════════════════════════════════════════════════════╣
║                                                               ║
║  WHY 1: "Tại sao HTTP dùng TCP thay vì UDP?"                ║
║  → Vì HTTP cần data đến ĐÚNG THỨ TỰ và ĐẦY ĐỦ.           ║
║    Nếu thiếu 1 byte trong JSON response → parse error!     ║
║                                                               ║
║  WHY 2: "Tại sao cần đúng thứ tự và đầy đủ?"              ║
║  → Vì IP layer KHÔNG ĐẢM BẢO gì cả!                       ║
║    Packets có thể: mất, trùng lặp, đến sai thứ tự,        ║
║    bị corrupt, hoặc đi đường vòng!                          ║
║                                                               ║
║  WHY 3: "Tại sao IP không đảm bảo?"                        ║
║  → Vì IP được thiết kế "best-effort" — cố gắng hết sức    ║
║    nhưng không hứa hẹn. Router chỉ forward packet,         ║
║    không track xem packet đã đến chưa.                      ║
║    Lý do: nếu mỗi router phải track → KHÔNG SCALE!        ║
║                                                               ║
║  WHY 4: "Tại sao router không track?"                       ║
║  → Vì internet có HÀNG TỶ connections đồng thời.           ║
║    Router xử lý TRIỆU packets/giây.                        ║
║    Lưu state cho mỗi connection = KHÔNG ĐỦ MEMORY!         ║
║    → "Stateless" routing = scalable routing.                ║
║                                                               ║
║  WHY 5: "Vậy ai chịu trách nhiệm reliability?"            ║
║  → END-TO-END PRINCIPLE!                                     ║
║    Hai đầu (sender + receiver) tự đảm bảo.                ║
║    Network chỉ lo CHUYỂN packet, không lo ĐÚNG/SAI.        ║
║    → TCP implement reliability ở 2 endpoints!               ║
║                                                               ║
║  ⭐ BÀI HỌC:                                                ║
║  End-to-End Principle = nguyên lý thiết kế CỐT LÕI:       ║
║  "Đặt logic phức tạp ở EDGE, giữ CORE đơn giản."         ║
║  → Giống microservices: business logic ở service,          ║
║    network mesh chỉ lo routing!                              ║
║                                                               ║
╚═══════════════════════════════════════════════════════════════╝
```

### 5 Whys cho từng cơ chế TCP

**Tại sao cần 3-Way Handshake?**

```
WHY 1: "Tại sao cần handshake trước khi gửi data?"
→ Vì TCP là connection-oriented: cần THIẾT LẬP trạng thái
  ở CẢ HAI BÊN trước khi truyền data.

WHY 2: "Tại sao cần trạng thái ở hai bên?"
→ Vì cần ĐỒNG BỘ Sequence Number ban đầu (ISN).
  Không có ISN → không biết packet nào đến trước/sau!

WHY 3: "Tại sao không dùng SEQ=0 luôn? Cần gì random ISN?"
→ Vì nếu luôn bắt đầu từ 0:
  - Connection cũ close, connection mới mở CÙNG port
  - Packet cũ (delayed) đến → bị nhầm là của connection mới!
  - Random ISN = TRÁNH nhầm lẫn giữa các connections!
  - Bonus: chống TCP sequence prediction attack!

WHY 4: "Tại sao 3 bước? Sao không 2 hoặc 4?"
→ 2 bước: client gửi SYN, server trả SYN-ACK
  → Client biết server sẵn sàng, NHƯNG server KHÔNG BIẾT
    client đã nhận SYN-ACK chưa!
  → Server gửi data mà client chưa ready → LÃNG PHÍ!
→ 3 bước: tối thiểu để CẢ HAI BÊN xác nhận lẫn nhau!
→ 4 bước: lãng phí — 3 đã đủ!

WHY 5: "3-way handshake tốn bao nhiêu?"
→ 1.5 RTT (Round Trip Time) trước khi gửi data!
  - SYN:     client → server (0.5 RTT)
  - SYN-ACK: server → client (0.5 RTT)
  - ACK:     client → server (0.5 RTT)
  → Nếu RTT = 50ms → mất 75ms chỉ để mở connection!
  → Nếu kết nối xuyên Đại Tây Dương (RTT ~150ms):
     → 225ms chỉ để handshake!
  → ĐÂY LÀ LÝ DO cần Connection Pooling!
```

**Tại sao cần Sequence Numbers?**

```
WHY 1: "Tại sao mỗi byte cần một number?"
→ Vì IP có thể giao packet SAI THỨ TỰ!
  Packet 3 có thể đến TRƯỚC packet 1.
  SEQ number cho phép receiver SẮP XẾP LẠI đúng thứ tự.

WHY 2: "Tại sao đánh số theo BYTE, không theo PACKET?"
→ Vì packets có thể bị CHIA NHỎ (fragmentation) hoặc
  GHÉP LẠI (coalescing) giữa đường.
  Đánh số theo byte → chính xác tuyệt đối!

WHY 3: "SEQ overflow thì sao? (32-bit = max ~4 billion)"
→ SEQ số WRAP AROUND! 4,294,967,295 → 0
  Ở 1 Gbps: wrap around mỗi ~34 giây!
  Ở 10 Gbps: wrap around mỗi ~3.4 giây!
  → RFC 7323: TCP Timestamps để phân biệt old vs new SEQ
  (PAWS — Protection Against Wrapped Sequences)
```

---

## §1. TCP Header — Anatomy Chi Tiết

### First Principles: TCP Header chứa gì và TẠI SAO?

```
╔═══════════════════════════════════════════════════════════════════════════╗
║   TCP HEADER FORMAT (RFC 793) — 20 bytes minimum, 60 bytes maximum      ║
╠═══════════════════════════════════════════════════════════════════════════╣
║                                                                           ║
║   0                   1                   2                   3           ║
║   0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1     ║
║  +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+       ║
║  |          Source Port          |       Destination Port         |       ║
║  +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+       ║
║  |                        Sequence Number                        |       ║
║  +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+       ║
║  |                    Acknowledgment Number                      |       ║
║  +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+       ║
║  | Data  |Reserv|C|E|U|A|P|R|S|F|                               |       ║
║  |Offset |  ed  |W|C|R|C|S|S|Y|I|          Window Size           |       ║
║  |       |      |R|E|G|K|H|T|N|N|                               |       ║
║  +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+       ║
║  |           Checksum            |         Urgent Pointer         |       ║
║  +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+       ║
║  |                    Options (if Data Offset > 5)               |       ║
║  +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+       ║
║  |                             Data                              |       ║
║  +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+       ║
║                                                                           ║
╚═══════════════════════════════════════════════════════════════════════════╝
```

### Giải thích từng field — Tại sao nó tồn tại?

```
┌───────────────────┬──────┬──────────────────────────────────────────┐
│ Field             │ Bits │ Tại sao cần?                             │
├───────────────────┼──────┼──────────────────────────────────────────┤
│ Source Port       │ 16   │ Identifier cho process gửi.              │
│                   │      │ 16 bits = max 65,535 ports.              │
│                   │      │ Port 0-1023: well-known (cần root)       │
│                   │      │ Port 1024-49151: registered              │
│                   │      │ Port 49152-65535: ephemeral (client)     │
├───────────────────┼──────┼──────────────────────────────────────────┤
│ Destination Port  │ 16   │ Identifier cho process nhận.             │
│                   │      │ TCP identify connection bằng 4-tuple:    │
│                   │      │ (src_ip, src_port, dst_ip, dst_port)     │
│                   │      │ → 1 server port 443 có thể serve        │
│                   │      │   HÀNG TRIỆU connections cùng lúc!      │
├───────────────────┼──────┼──────────────────────────────────────────┤
│ Sequence Number   │ 32   │ Đánh số từng BYTE data gửi đi.         │
│                   │      │ → Receiver biết thứ tự đúng.            │
│                   │      │ → Phát hiện packet trùng lặp.           │
│                   │      │ ISN (Initial Sequence Number) random!    │
├───────────────────┼──────┼──────────────────────────────────────────┤
│ ACK Number        │ 32   │ "Tôi đã nhận đến byte X-1,             │
│                   │      │  gửi byte X tiếp đi!"                   │
│                   │      │ = Cumulative acknowledgment             │
├───────────────────┼──────┼──────────────────────────────────────────┤
│ Data Offset       │ 4    │ Header dài bao nhiêu (tính bằng 32-bit │
│                   │      │ words). Min=5 (20 bytes), Max=15        │
│                   │      │ (60 bytes). Cần vì Options có thể thay  │
│                   │      │ đổi header length.                       │
├───────────────────┼──────┼──────────────────────────────────────────┤
│ Flags (9 bits)    │      │ Control bits — điều khiển connection:   │
│  SYN              │ 1    │ "Tôi muốn BẮT ĐẦU connection"          │
│  ACK              │ 1    │ "Tôi XÁC NHẬN đã nhận data"            │
│  FIN              │ 1    │ "Tôi muốn KẾT THÚC connection"         │
│  RST              │ 1    │ "RESET! Có lỗi, hủy connection ngay!"  │
│  PSH              │ 1    │ "Gửi data lên app NGAY, đừng buffer!"  │
│  URG              │ 1    │ "Data này KHẨN CẤP!" (hiếm khi dùng)   │
│  ECE              │ 1    │ ECN-Echo: "Mạng đang tắc nghẽn!"       │
│  CWR              │ 1    │ "Tôi đã giảm tốc rồi" (response ECE)  │
│  NS               │ 1    │ Nonce Sum (ECN protection)              │
├───────────────────┼──────┼──────────────────────────────────────────┤
│ Window Size       │ 16   │ Flow control: "Tôi còn nhận được X     │
│                   │      │ bytes nữa, ĐỪNG gửi nhiều hơn!"        │
│                   │      │ 16 bits = max 65,535 bytes (quá nhỏ!)   │
│                   │      │ → Window Scaling option: ×2^n           │
│                   │      │ → Max thực tế: 65,535 × 2^14 = 1 GB!   │
├───────────────────┼──────┼──────────────────────────────────────────┤
│ Checksum          │ 16   │ Phát hiện data bị corrupt trên đường.  │
│                   │      │ Tính trên header + data + pseudo-header │
│                   │      │ (IP addresses). Weak nhưng nhanh.       │
│                   │      │ ⚠️ Chỉ phát hiện, KHÔNG sửa!           │
├───────────────────┼──────┼──────────────────────────────────────────┤
│ Urgent Pointer    │ 16   │ Chỉ đến urgent data trong stream.      │
│                   │      │ Gần như không ai dùng nữa.              │
│                   │      │ Telnet dùng cho Ctrl+C (interrupt).     │
├───────────────────┼──────┼──────────────────────────────────────────┤
│ Options (0-40B)   │ var  │ Mở rộng TCP capabilities:              │
│  MSS              │      │ Max Segment Size (thường 1460 bytes)   │
│  Window Scale     │      │ Nhân Window Size lên (RFC 7323)        │
│  SACK             │      │ Selective ACK — ACK chọn lọc           │
│  Timestamps       │      │ RTT measurement + PAWS protection      │
│  TFO Cookie       │      │ TCP Fast Open — data trong SYN!        │
└───────────────────┴──────┴──────────────────────────────────────────┘
```

### TCP Header Overhead — Bài toán kinh tế

```
╔═══════════════════════════════════════════════════════════════╗
║   OVERHEAD ANALYSIS                                           ║
╠═══════════════════════════════════════════════════════════════╣
║                                                               ║
║  Ethernet frame:                                              ║
║  [Ethernet 14B][IP 20B][TCP 20B][DATA ≤1460B][FCS 4B]      ║
║                                                               ║
║  Overhead per packet:                                        ║
║  → Ethernet: 14 bytes                                        ║
║  → IP: 20 bytes                                              ║
║  → TCP: 20 bytes (minimum)                                   ║
║  → Total overhead: 54 bytes MINIMUM per packet              ║
║                                                               ║
║  Efficiency:                                                  ║
║  → Full packet (1460B data): 1460/1514 = 96.4% efficient   ║
║  → Small packet (1B data): 1/55 = 1.8% efficient!          ║
║  → ACK-only (0B data): 0/54 = 0% useful data!              ║
║                                                               ║
║  ⚠️ BÀI HỌC CHO BACKEND:                                   ║
║  → Gửi nhiều small messages = LÃNG PHÍ bandwidth!          ║
║  → Nagle's Algorithm: gom small packets lại                 ║
║  → Nhưng Nagle + Delayed ACK = latency tăng! (xem §4)      ║
║  → Đây là trade-off kinh điển: throughput vs latency!       ║
║                                                               ║
╚═══════════════════════════════════════════════════════════════╝
```

---

## §2. Connection Lifecycle — Vòng Đời Kết Nối

### 2.1 Three-Way Handshake — Chi Tiết Từng Bước

```
╔═══════════════════════════════════════════════════════════════════════════╗
║   THREE-WAY HANDSHAKE — THIẾT LẬP KẾT NỐI TCP                         ║
╠═══════════════════════════════════════════════════════════════════════════╣
║                                                                           ║
║     Client                                         Server                 ║
║     ──────                                         ──────                 ║
║     CLOSED                                         LISTEN                 ║
║       │                                               │                   ║
║       │  ①  SYN (SEQ=x)                              │                   ║
║       │  "Tôi muốn kết nối, ISN của tôi là x"       │                   ║
║       │──────────────────────────────────────────────►│                   ║
║       │                                               │                   ║
║    SYN_SENT                                       SYN_RCVD               ║
║       │                                               │                   ║
║       │  ②  SYN-ACK (SEQ=y, ACK=x+1)                │                   ║
║       │  "OK! ISN của tôi là y, tôi nhận SYN của bạn"│                  ║
║       │◄──────────────────────────────────────────────│                   ║
║       │                                               │                   ║
║       │  ③  ACK (SEQ=x+1, ACK=y+1)                  │                   ║
║       │  "Tôi nhận SYN-ACK, sẵn sàng!"              │                   ║
║       │──────────────────────────────────────────────►│                   ║
║       │                                               │                   ║
║   ESTABLISHED ◄──────── DATA TRANSFER ───────► ESTABLISHED              ║
║       │                                               │                   ║
║       │ Thời gian: 1.5 RTT (Round Trip Time)         │                   ║
║       │ Nếu RTT = 50ms → 75ms chỉ để mở connection  │                   ║
║       │ + TLS 1.3: thêm 1 RTT = 125ms total!        │                   ║
║       │ + TLS 1.2: thêm 2 RTT = 175ms total!        │                   ║
║                                                                           ║
╚═══════════════════════════════════════════════════════════════════════════╝
```

**SYN Queue và Accept Queue — Kiến thức Production:**

```
╔═══════════════════════════════════════════════════════════════╗
║   SERVER-SIDE CONNECTION QUEUES                               ║
╠═══════════════════════════════════════════════════════════════╣
║                                                               ║
║  Client SYN ──► ┌──────────────┐  SYN-ACK+ACK  ┌─────────┐ ║
║                 │  SYN Queue   │ ─────────────► │ Accept  │ ║
║                 │  (half-open) │                │ Queue   │ ║
║                 │              │                │(complete)│ ║
║                 │ syn_backlog  │                │ backlog  │ ║
║                 └──────────────┘                └────┬────┘ ║
║                                                      │      ║
║                                              accept() call  ║
║                                                      │      ║
║                                                      ▼      ║
║                                              Application     ║
║                                                               ║
║  SYN Queue overflow:                                         ║
║  → Kernel DROP SYN → client retransmit (1s, 2s, 4s...)     ║
║  → User thấy: "connection timeout"                          ║
║  → Fix: sysctl net.ipv4.tcp_max_syn_backlog=4096           ║
║                                                               ║
║  Accept Queue overflow:                                      ║
║  → Kernel DROP hoặc RST connection đã handshake xong       ║
║  → App quá chậm gọi accept() = BOTTLENECK!                 ║
║  → Fix: tăng backlog trong listen(fd, backlog)              ║
║  → Go: net.Listen tự set somaxconn                         ║
║                                                               ║
║  ⚠️ SYN FLOOD ATTACK:                                       ║
║  → Attacker gửi TRIỆU SYN, không bao giờ hoàn thành      ║
║  → SYN queue TRÀN → server không accept connection mới!    ║
║  → Fix: SYN Cookies (stateless SYN handling)               ║
║  → sysctl net.ipv4.tcp_syncookies=1                        ║
║                                                               ║
╚═══════════════════════════════════════════════════════════════╝
```

### 2.2 Four-Way Teardown — Đóng Kết Nối

```
╔═══════════════════════════════════════════════════════════════════════════╗
║   FOUR-WAY TEARDOWN — ĐÓNG KẾT NỐI TCP                                 ║
╠═══════════════════════════════════════════════════════════════════════════╣
║                                                                           ║
║     Client                                         Server                 ║
║   ESTABLISHED                                    ESTABLISHED             ║
║       │                                               │                   ║
║       │  ①  FIN (SEQ=u)                              │                   ║
║       │  "Tôi gửi xong rồi, muốn đóng"             │                   ║
║       │──────────────────────────────────────────────►│                   ║
║       │                                               │                   ║
║    FIN_WAIT_1                                     CLOSE_WAIT              ║
║       │                                               │                   ║
║       │  ②  ACK (ACK=u+1)                            │                   ║
║       │  "OK, tôi nhận FIN"                          │                   ║
║       │◄──────────────────────────────────────────────│                   ║
║       │                                               │                   ║
║    FIN_WAIT_2     (Server vẫn có thể GỬI DATA!)   CLOSE_WAIT            ║
║       │                                               │                   ║
║       │           ... server gửi nốt data ...        │                   ║
║       │                                               │                   ║
║       │  ③  FIN (SEQ=v)                              │                   ║
║       │  "Tôi cũng gửi xong, đóng thôi"            │                   ║
║       │◄──────────────────────────────────────────────│                   ║
║       │                                               │                   ║
║    TIME_WAIT                                       LAST_ACK               ║
║       │                                               │                   ║
║       │  ④  ACK (ACK=v+1)                            │                   ║
║       │  "OK, bye!"                                  │                   ║
║       │──────────────────────────────────────────────►│                   ║
║       │                                               │                   ║
║    TIME_WAIT                                        CLOSED                ║
║    (đợi 2×MSL)                                                           ║
║       │                                                                   ║
║    ... 60 giây sau ...                                                   ║
║       │                                                                   ║
║     CLOSED                                                                ║
║                                                                           ║
║  ⚠️ TẠI SAO 4 BƯỚC? (không phải 3 như handshake)                       ║
║  → TCP là FULL-DUPLEX: mỗi hướng đóng RIÊNG RẼ!                       ║
║  → Client close ≠ server close: server có thể còn data!               ║
║  → FIN = "tôi KHÔNG GỬI thêm" (vẫn có thể NHẬN!)                     ║
║                                                                           ║
╚═══════════════════════════════════════════════════════════════════════════╝
```

### 2.3 TIME_WAIT — Trạng Thái "Đáng Sợ" Nhất

TIME_WAIT là trạng thái gây nhiều production issue nhất cho backend engineer. Hiểu kỹ nó là MUST.

**Tại sao TIME_WAIT tồn tại? (5 Whys)**

```
WHY 1: "Tại sao cần đợi 2×MSL (60-120 giây) sau khi đóng?"
→ Vì ACK cuối cùng (bước ④) có thể BỊ MẤT!

WHY 2: "ACK cuối mất thì sao?"
→ Server không nhận ACK → retransmit FIN → client phải
  có khả năng GỬI LẠI ACK! Nếu đã CLOSED → gửi RST
  → server nghĩ connection bị lỗi!

WHY 3: "Còn lý do nào khác?"
→ Đảm bảo tất cả DELAYED PACKETS trong mạng đã hết hạn!
  Nếu reuse port ngay → delayed packet từ connection cũ
  có thể bị nhầm là của connection MỚI!

WHY 4: "2×MSL = bao lâu?"
→ MSL = Maximum Segment Lifetime = 60 giây (RFC 793)
  → 2×MSL = 120 giây (2 phút!) trên nhiều hệ thống
  → Linux default: 60 giây (net.ipv4.tcp_fin_timeout)

WHY 5: "Vậy 50,000 connection close → 50,000 TIME_WAIT
         trong 60 giây! Hết port không?"
→ ĐÚNG! Đây là vấn đề thực tế:
  Ephemeral ports: 49152-65535 = ~16,000 ports
  Với 1 destination IP → max 16,000 connections/60s!
  → Fix: tcp_tw_reuse=1, connection pooling, keep-alive!
```

**TIME_WAIT trong Production — Bảng phân tích:**

```
┌──────────────────────┬────────────────────────────────────────┐
│ Vấn đề               │ Giải pháp                              │
├──────────────────────┼────────────────────────────────────────┤
│ TIME_WAIT quá nhiều  │ 1. Connection pooling (QUAN TRỌNG!)   │
│ (> 10,000)           │ 2. sysctl net.ipv4.tcp_tw_reuse=1     │
│                      │ 3. Keep-alive connections              │
│                      │ 4. Giảm tcp_fin_timeout (30-15s)      │
├──────────────────────┼────────────────────────────────────────┤
│ CLOSE_WAIT tích lũy  │ → BUG! App không gọi Close()!        │
│ (= resource leak!)   │ → Go: defer conn.Close()              │
│                      │ → Go: defer resp.Body.Close()         │
│                      │ → Đọc hết body: io.Copy(io.Discard,  │
│                      │   resp.Body)                           │
├──────────────────────┼────────────────────────────────────────┤
│ Port exhaustion      │ 1. Tăng ephemeral range:              │
│                      │    ip_local_port_range="1024 65535"    │
│                      │ 2. tcp_tw_reuse=1 (reuse TIME_WAIT)   │
│                      │ 3. Dùng connection pool!               │
│                      │ 4. Multiple source IPs                 │
├──────────────────────┼────────────────────────────────────────┤
│ ⚠️ ĐỪNG dùng:       │ tcp_tw_recycle → REMOVED khỏi Linux  │
│                      │ 4.12! Gây lỗi với NAT/LB vì conflict │
│                      │ TCP timestamps!                        │
└──────────────────────┴────────────────────────────────────────┘
```

### 2.4 TCP State Machine — Toàn Bộ Trạng Thái

```
╔═══════════════════════════════════════════════════════════════════════════╗
║   TCP STATE MACHINE — 11 TRẠNG THÁI                                     ║
╠═══════════════════════════════════════════════════════════════════════════╣
║                                                                           ║
║                         ┌────────┐                                        ║
║                         │ CLOSED │                                        ║
║                         └───┬────┘                                        ║
║                    ┌────────┴────────┐                                    ║
║              passive open      active open                                ║
║                    │                │                                      ║
║                    ▼                ▼                                      ║
║              ┌──────────┐    ┌──────────┐                                ║
║              │  LISTEN  │    │ SYN_SENT │                                ║
║              └────┬─────┘    └────┬─────┘                                ║
║            rcv SYN│          rcv SYN-ACK│                                 ║
║            snd SYN-ACK      snd ACK    │                                 ║
║                   │               │                                       ║
║                   ▼               │                                       ║
║            ┌──────────┐          │                                        ║
║            │ SYN_RCVD │──────────┘                                       ║
║            └────┬─────┘ rcv ACK                                          ║
║                 │                                                         ║
║                 ▼                                                         ║
║          ┌─────────────┐                                                  ║
║          │ ESTABLISHED │ ◄── DATA TRANSFER xảy ra ở đây!               ║
║          └──────┬──────┘                                                  ║
║           ┌─────┴─────┐                                                   ║
║      close│           │rcv FIN                                            ║
║      snd FIN          │snd ACK                                            ║
║           │           │                                                   ║
║           ▼           ▼                                                   ║
║    ┌────────────┐ ┌────────────┐                                         ║
║    │ FIN_WAIT_1 │ │ CLOSE_WAIT │ ← App cần gọi close()!               ║
║    └─────┬──────┘ └─────┬──────┘                                         ║
║     rcv ACK│       close│                                                 ║
║           │        snd FIN                                                ║
║           ▼             │                                                 ║
║    ┌────────────┐       │                                                 ║
║    │ FIN_WAIT_2 │       │                                                 ║
║    └─────┬──────┘       ▼                                                 ║
║     rcv FIN│     ┌────────────┐                                          ║
║     snd ACK│     │  LAST_ACK  │                                          ║
║           │      └─────┬──────┘                                           ║
║           ▼       rcv ACK│                                                ║
║    ┌────────────┐       │                                                 ║
║    │ TIME_WAIT  │       ▼                                                 ║
║    │ (2×MSL)    │  ┌────────┐                                            ║
║    └─────┬──────┘  │ CLOSED │                                            ║
║     timeout│       └────────┘                                             ║
║           ▼                                                               ║
║    ┌────────┐                                                             ║
║    │ CLOSED │                                                             ║
║    └────────┘                                                             ║
║                                                                           ║
║  Backend Engineer cần nhớ:                                               ║
║  → ESTABLISHED = bình thường, data đang truyền                          ║
║  → TIME_WAIT = bình thường (nhưng NHIỀU = warning!)                     ║
║  → CLOSE_WAIT = BUG! App không close connection!                        ║
║  → SYN_RECV nhiều = có thể SYN Flood attack!                           ║
║  → FIN_WAIT_2 kéo dài = peer không gửi FIN (peer hang?)               ║
║                                                                           ║
╚═══════════════════════════════════════════════════════════════════════════╝
```

### Go Code: Connection Lifecycle — Quan Sát States

```go
// Go: quan sát TCP states trong production
package main

import (
    "fmt"
    "net"
    "net/http"
    "os/exec"
    "strings"
    "time"
)

func showTCPStates() {
    out, _ := exec.Command("ss", "-tan").Output()
    states := map[string]int{}
    for _, line := range strings.Split(string(out), "\n") {
        fields := strings.Fields(line)
        if len(fields) > 0 {
            states[fields[0]]++
        }
    }
    fmt.Println("=== TCP Connection States ===")
    for state, count := range states {
        fmt.Printf("  %-15s %d\n", state, count)
    }
}

func main() {
    // Tạo HTTP server
    go func() {
        http.HandleFunc("/", func(w http.ResponseWriter, r *http.Request) {
            fmt.Fprintln(w, "Hello TCP!")
        })
        http.ListenAndServe(":8080", nil)
    }()
    time.Sleep(100 * time.Millisecond)

    // Tạo nhiều connections
    for i := 0; i < 100; i++ {
        conn, err := net.Dial("tcp", "localhost:8080")
        if err != nil {
            fmt.Printf("Connection %d failed: %v\n", i, err)
            continue
        }
        // Gửi HTTP request
        fmt.Fprintf(conn, "GET / HTTP/1.1\r\nHost: localhost\r\n\r\n")
        buf := make([]byte, 1024)
        conn.Read(buf)
        conn.Close() // → Tạo TIME_WAIT!
    }

    time.Sleep(1 * time.Second)

    // Quan sát TIME_WAIT
    showTCPStates()
    //  Output:
    //  ESTAB           1
    //  LISTEN          1
    //  TIME-WAIT       100  ← 100 connections vừa close!
}
```

```go
// Go: HTTP Client đúng cách — TRÁNH TIME_WAIT explosion
package main

import (
    "fmt"
    "io"
    "net/http"
    "time"
)

func main() {
    // ❌ SAI: tạo client MỚI mỗi request
    // → Mỗi request = new TCP connection = new TIME_WAIT khi close!
    for i := 0; i < 100; i++ {
        resp, _ := http.Get("https://httpbin.org/get")
        resp.Body.Close() // Vẫn tạo TIME_WAIT!
    }

    // ✅ ĐÚNG: dùng SHARED client với connection pooling
    client := &http.Client{
        Transport: &http.Transport{
            MaxIdleConns:        100,              // total idle connections
            MaxIdleConnsPerHost: 10,               // per-host idle connections
            IdleConnTimeout:     90 * time.Second, // idle timeout
            // ⚠️ Default MaxIdleConnsPerHost = 2!
            // → Nếu gửi 100 concurrent requests → 98 connections
            //   sẽ CLOSE ngay → TIME_WAIT!
        },
        Timeout: 30 * time.Second,
    }

    for i := 0; i < 100; i++ {
        resp, err := client.Do(mustNewRequest("GET", "https://httpbin.org/get"))
        if err != nil {
            continue
        }
        // ⚠️ PHẢI đọc HẾT body trước khi close!
        // Nếu không → connection không thể reuse!
        io.Copy(io.Discard, resp.Body)
        resp.Body.Close()
    }

    fmt.Println("Done! Connections reused, minimal TIME_WAIT")
}

func mustNewRequest(method, url string) *http.Request {
    req, _ := http.NewRequest(method, url, nil)
    return req
}
```

---

## §3. Reliability Engine — Cơ Chế Đảm Bảo Tin Cậy

### First Principles: TCP đảm bảo gì?

TCP cung cấp **4 đảm bảo** trên nền IP không tin cậy:

```
╔═══════════════════════════════════════════════════════════════╗
║   4 ĐẢM BẢO CỦA TCP                                        ║
╠═══════════════════════════════════════════════════════════════╣
║                                                               ║
║  1. ORDERED DELIVERY (đúng thứ tự)                           ║
║     → Sequence numbers + receiver buffer                     ║
║     → Data luôn đến app đúng thứ tự, dù network sai       ║
║                                                               ║
║  2. RELIABLE DELIVERY (đầy đủ)                              ║
║     → ACK + retransmission                                   ║
║     → Mỗi byte được ACK, nếu không → gửi lại!             ║
║                                                               ║
║  3. ERROR DETECTION (phát hiện lỗi)                         ║
║     → Checksum trên header + data                           ║
║     → Data bị corrupt → discard + retransmit               ║
║                                                               ║
║  4. NO DUPLICATES (không trùng lặp)                         ║
║     → SEQ number phát hiện duplicate packets                ║
║     → Receiver discard packets đã nhận                      ║
║                                                               ║
║  CÁI GIÁ PHẢI TRẢ:                                          ║
║  → Latency tăng (handshake, retransmit wait)                ║
║  → Overhead tăng (ACK packets, header)                      ║
║  → Head-of-line blocking (packet sau PHẢI đợi packet trước)║
║  → Memory tăng (buffers cho reordering)                     ║
║                                                               ║
╚═══════════════════════════════════════════════════════════════╝
```

### 3.1 Sequence Numbers & ACK — Cơ Chế Core

```
╔═══════════════════════════════════════════════════════════════════════════╗
║   SEQ/ACK MECHANISM — VÍ DỤ THỰC TẾ                                    ║
╠═══════════════════════════════════════════════════════════════════════════╣
║                                                                           ║
║  Client muốn gửi "HELLO WORLD" (11 bytes) cho Server                    ║
║  Client ISN = 1000, Server ISN = 5000                                    ║
║                                                                           ║
║  Client                                           Server                  ║
║    │                                                 │                    ║
║    │  SEQ=1000, Len=5, Data="HELLO"                 │                    ║
║    │────────────────────────────────────────────────►│                    ║
║    │                                                 │  Nhận bytes        ║
║    │                          ACK=1005               │  1000-1004         ║
║    │◄────────────────────────────────────────────────│  "Gửi 1005 đi!"  ║
║    │                                                 │                    ║
║    │  SEQ=1005, Len=6, Data=" WORLD"                │                    ║
║    │────────────────────────────────────────────────►│                    ║
║    │                                                 │  Nhận bytes        ║
║    │                          ACK=1011               │  1005-1010         ║
║    │◄────────────────────────────────────────────────│  "Gửi 1011 đi!"  ║
║    │                                                 │                    ║
║                                                                           ║
║  ACK = "Tôi đã nhận TẤT CẢ bytes ĐẾN số này - 1"                     ║
║  ACK = 1005 nghĩa là "đã nhận 1000,1001,1002,1003,1004"               ║
║                                                                           ║
║  ⚠️ CUMULATIVE ACK: ACK xác nhận TẤT CẢ bytes trước nó!              ║
║  Nếu ACK=1011 → "tôi đã nhận mọi thứ từ 1000 đến 1010"              ║
║  Nhưng... nếu packet 2 mất, packet 3 đến → chỉ ACK=1005!             ║
║  → Receiver biết MẤT packet nhưng không nói CỤ THỂ packet nào!        ║
║  → SACK (Selective ACK) giải quyết vấn đề này!                        ║
║                                                                           ║
╚═══════════════════════════════════════════════════════════════════════════╝
```

### 3.2 Retransmission — Gửi Lại Khi Mất

```
╔═══════════════════════════════════════════════════════════════╗
║   RETRANSMISSION MECHANISMS                                   ║
╠═══════════════════════════════════════════════════════════════╣
║                                                               ║
║  Cơ chế 1: TIMEOUT-BASED RETRANSMISSION                     ║
║  ─────────────────────────────────────                       ║
║  Sender gửi packet → start timer (RTO)                      ║
║  Nếu không nhận ACK trước khi timer hết → GỬI LẠI!        ║
║                                                               ║
║  RTO (Retransmission Timeout) calculation:                   ║
║  → Dựa trên RTT (Round Trip Time) đo được                  ║
║  → SRTT = (1-α)×SRTT + α×RTT  (α = 1/8)                  ║
║  → RTTVAR = (1-β)×RTTVAR + β×|SRTT-RTT|  (β = 1/4)      ║
║  → RTO = SRTT + 4×RTTVAR                                   ║
║  → Min RTO = 200ms (Linux), Max = 120s                     ║
║                                                               ║
║  Exponential Backoff: mỗi lần timeout → RTO × 2            ║
║  → 1s → 2s → 4s → 8s → 16s → 32s → 64s → GIỮ 120s     ║
║  → Sau ~15 lần retry → GIVE UP (khoảng 15 phút!)          ║
║                                                               ║
║  Cơ chế 2: FAST RETRANSMIT (3 Duplicate ACKs)              ║
║  ─────────────────────────────────────────────               ║
║  Nhanh hơn timeout! Không cần đợi RTO expires.             ║
║                                                               ║
║  Sender         Network          Receiver                    ║
║    │  SEQ=100 ──────────────────► │  ACK=200 (OK)           ║
║    │  SEQ=200 ──── X (mất!)      │                          ║
║    │  SEQ=300 ──────────────────► │  ACK=200 (DupACK #1!)  ║
║    │  SEQ=400 ──────────────────► │  ACK=200 (DupACK #2!)  ║
║    │  SEQ=500 ──────────────────► │  ACK=200 (DupACK #3!)  ║
║    │                               │                          ║
║    │  3 DupACKs! → Fast Retransmit SEQ=200 ngay!           ║
║    │  SEQ=200 ──────────────────► │  ACK=600 (tất cả OK!) ║
║    │                               │                          ║
║  → KHÔNG CẦN ĐỢI TIMEOUT!                                  ║
║  → Phát hiện mất packet trong ~1 RTT thay vì RTO!         ║
║                                                               ║
║  Cơ chế 3: SACK (Selective Acknowledgment)                  ║
║  ─────────────────────────────────────────                   ║
║  Receiver nói CỤ THỂ blocks nào đã nhận:                   ║
║  ACK=200, SACK=300-500                                       ║
║  → "Tôi thiếu 200-299, nhưng đã có 300-499!"              ║
║  → Sender CHỈ CẦN gửi lại 200-299! Tiết kiệm bandwidth!  ║
║                                                               ║
╚═══════════════════════════════════════════════════════════════╝
```

---

## §4. Flow Control — Kiểm Soát Luồng

### Tại sao cần Flow Control?

```
Sender nhanh + Receiver chậm = THẢM HỌA!

Ví dụ thực tế:
→ Server gửi data 1 Gbps
→ Client (mobile 3G) nhận chỉ 1 Mbps
→ Không có flow control → client buffer TRÀN → data MẤT!

Analogy:
→ Như một vòi nước (sender) xả vào một cái xô (receiver buffer)
→ Nếu xả quá nhanh, xô tràn, nước (data) mất!
→ Flow control = receiver nói "CHẬM LẠI!" hoặc "OK, tiếp đi!"
```

### Sliding Window Protocol

```
╔═══════════════════════════════════════════════════════════════════════════╗
║   SLIDING WINDOW — FLOW CONTROL MECHANISM                               ║
╠═══════════════════════════════════════════════════════════════════════════╣
║                                                                           ║
║  Receiver buffer size = 4 segments (ví dụ đơn giản)                     ║
║                                                                           ║
║  Receiver gửi: Window Size = 4                                           ║
║  "Tôi còn chỗ cho 4 segments, gửi tối đa 4!"                          ║
║                                                                           ║
║  Sender's Window (những gì được phép gửi):                              ║
║                                                                           ║
║  ┌───┬───┬───┬───┬───┬───┬───┬───┬───┬───┐                             ║
║  │ 1 │ 2 │ 3 │ 4 │ 5 │ 6 │ 7 │ 8 │ 9 │10 │                            ║
║  └───┴───┴───┴───┴───┴───┴───┴───┴───┴───┘                             ║
║  ◄──ACKed──►◄────WINDOW (gửi được)────►◄─chờ─►                        ║
║                                                                           ║
║  Khi receiver ACK segment 1:                                             ║
║  → Window TRƯỢT sang phải!                                              ║
║                                                                           ║
║  ┌───┬───┬───┬───┬───┬───┬───┬───┬───┬───┐                             ║
║  │ 1 │ 2 │ 3 │ 4 │ 5 │ 6 │ 7 │ 8 │ 9 │10 │                            ║
║  └───┴───┴───┴───┴───┴───┴───┴───┴───┴───┘                             ║
║  ◄──ACKed──────►◄────WINDOW────────────►◄─chờ─►                        ║
║                                                                           ║
║  ⚠️ ZERO WINDOW:                                                        ║
║  Receiver buffer ĐẦY → gửi Window=0                                    ║
║  → Sender PHẢI DỪNG gửi data!                                           ║
║  → Sender gửi WINDOW PROBE (1 byte) định kỳ                            ║
║    để hỏi "đã có chỗ chưa?"                                            ║
║  → Zero Window = receiver đang overwhelmed!                             ║
║  → Trong Wireshark: tcp.analysis.zero_window                            ║
║                                                                           ║
║  Window Scaling (RFC 7323):                                              ║
║  → Window field = 16 bits = max 65,535 bytes (quá nhỏ!)                ║
║  → Window Scale option: shift count 0-14                                ║
║  → Actual window = Window field × 2^scale                              ║
║  → Scale=7: 65,535 × 128 = ~8 MB window!                              ║
║  → PHẢI negotiate trong SYN/SYN-ACK!                                   ║
║                                                                           ║
║  Bandwidth-Delay Product (BDP):                                         ║
║  → Optimal window = Bandwidth × RTT                                    ║
║  → 1 Gbps, RTT=50ms: BDP = 1,000,000,000 × 0.05 / 8 = 6.25 MB       ║
║  → Window < BDP = pipe không đầy = LÃNG PHÍ bandwidth!               ║
║  → Window > BDP = sender gửi quá nhiều = congestion!                  ║
║                                                                           ║
╚═══════════════════════════════════════════════════════════════════════════╝
```

### Nagle's Algorithm vs Delayed ACK — Interaction Kinh Điển

```
╔═══════════════════════════════════════════════════════════════╗
║   NAGLE + DELAYED ACK = LATENCY TRAP!                        ║
╠═══════════════════════════════════════════════════════════════╣
║                                                               ║
║  Nagle's Algorithm (sender side):                            ║
║  "Nếu có small data ĐỢI gửi VÀ có unACKed data            ║
║   → GOM small data lại, đợi ACK rồi gửi cùng lúc"         ║
║  Mục đích: tránh gửi nhiều tiny packets (< MSS)            ║
║                                                               ║
║  Delayed ACK (receiver side):                                ║
║  "Đừng ACK ngay, đợi 40-200ms hoặc đến khi có data        ║
║   gửi ngược lại → gộp ACK vào data packet"                 ║
║  Mục đích: giảm số ACK-only packets                        ║
║                                                               ║
║  VẤN ĐỀ khi 2 cái KẾT HỢP:                                 ║
║  ──────────────────────────                                  ║
║  1. App gửi small message (< MSS)                           ║
║  2. Nagle: "có unACKed data → GOM, đợi ACK"               ║
║  3. Receiver: Delayed ACK → "đợi 200ms rồi ACK"           ║
║  4. Sender đợi ACK... Receiver đợi data...                 ║
║  5. Sau 200ms: receiver timeout → gửi ACK                  ║
║  6. Sender nhận ACK → GÌ gửi small data                    ║
║  → TỔNG: 200ms delay cho mỗi small message!                ║
║                                                               ║
║  FIX:                                                         ║
║  → TCP_NODELAY = tắt Nagle (gửi NGAY, không gom)           ║
║  → Go: conn.(*net.TCPConn).SetNoDelay(true)                ║
║  → HTTP/2, gRPC: luôn set TCP_NODELAY!                      ║
║  → Database driver: thường đã set TCP_NODELAY               ║
║                                                               ║
║  ⚠️ NHƯNG: tắt Nagle = nhiều tiny packets = overhead!      ║
║  → Trade-off: latency (TCP_NODELAY=true) vs                ║
║               throughput (TCP_NODELAY=false)                 ║
║  → Interactive apps (chat, game): TCP_NODELAY=true          ║
║  → Bulk transfer (file upload): TCP_NODELAY=false           ║
║                                                               ║
╚═══════════════════════════════════════════════════════════════╝
```

---

## §5. Congestion Control — Kiểm Soát Tắc Nghẽn

### Contextual History: Internet Congestion Collapse 1986

Tháng 10/1986, internet gần như **SẬP HOÀN TOÀN**. Throughput giữa LBL và UC Berkeley giảm từ 32 Kbps xuống **40 bps** — giảm 1000 lần! Nguyên nhân: **congestion collapse** — tất cả máy tính gửi data tối đa, router tràn, packet mất, máy gửi lại, càng tràn hơn → vòng lặp tử thần!

**Van Jacobson** đã cứu internet bằng 4 thuật toán congestion control:

```
╔═══════════════════════════════════════════════════════════════╗
║   CONGESTION CONTROL — TRÁNH LÀM SẬP MẠNG!                 ║
╠═══════════════════════════════════════════════════════════════╣
║                                                               ║
║  Flow Control vs Congestion Control:                         ║
║  ────────────────────────────────────                        ║
║  Flow Control: RECEIVER nói "tôi nhận được bao nhiêu"      ║
║  Congestion:   NETWORK nói "mạng chịu được bao nhiêu"      ║
║                                                               ║
║  Sender gửi ≤ min(rwnd, cwnd)                               ║
║  → rwnd = Receiver Window (flow control)                    ║
║  → cwnd = Congestion Window (congestion control)            ║
║  → Gửi ≤ giá trị NHỎ HƠN!                                ║
║                                                               ║
╚═══════════════════════════════════════════════════════════════╝
```

### 5.1 Slow Start — Bắt Đầu Chậm, Tăng Nhanh

```
╔═══════════════════════════════════════════════════════════════╗
║   SLOW START — MỖI RTT, CWND × 2!                           ║
╠═══════════════════════════════════════════════════════════════╣
║                                                               ║
║  Tên "Slow Start" GÂY HIỂU LẦM — nó tăng RẤT NHANH!     ║
║                                                               ║
║  cwnd (segments)                                             ║
║    │                                     ssthresh            ║
║    │                                        │                ║
║  64│                                ........│................║
║    │                         ·······        │                ║
║  32│                    ·····               │                ║
║    │                ····                    │                ║
║  16│            ····                        │                ║
║    │         ···                             │                ║
║   8│       ··                                │                ║
║    │     ··                                  │                ║
║   4│    ·                                    │                ║
║    │   ·                                     │                ║
║   2│  ·                                      │                ║
║   1│ ·                                       │                ║
║    └────────────────────────────────────── RTT              ║
║     1   2   3   4   5   6   7   8   9  10                   ║
║                                                               ║
║  Algorithm:                                                   ║
║  1. Bắt đầu: cwnd = 1 MSS (hoặc 10 MSS trên Linux mới)   ║
║  2. Mỗi ACK nhận được: cwnd += 1 MSS                       ║
║  3. Hiệu quả: mỗi RTT, cwnd GẤP ĐÔI! (exponential)      ║
║  4. Tiếp tục cho đến khi:                                    ║
║     a) cwnd ≥ ssthresh → chuyển sang Congestion Avoidance  ║
║     b) Packet loss → giảm cwnd drastically                  ║
║     c) cwnd ≥ rwnd → limited by receiver                    ║
║                                                               ║
║  ⚠️ VẤN ĐỀ CHO BACKEND:                                    ║
║  Connection MỚI luôn bắt đầu với cwnd NHỎ!                 ║
║  → 10 MSS = ~14.6 KB → chỉ gửi được 14.6 KB/RTT đầu!    ║
║  → Nếu webpage = 100 KB + RTT = 50ms:                      ║
║    RTT 1: 14.6 KB (cwnd=10)                                 ║
║    RTT 2: 29.2 KB (cwnd=20)                                 ║
║    RTT 3: 58.4 KB (cwnd=40)                                 ║
║    RTT 4: xong! → 4 RTT = 200ms chỉ cho Slow Start!       ║
║  → THÊM 75ms handshake + 50ms TLS = 325ms tổng!           ║
║  → ĐÂY LÀ LÝ DO "Keep connections alive!"                 ║
║                                                               ║
╚═══════════════════════════════════════════════════════════════╝
```

### 5.2 Congestion Avoidance — Tăng Cẩn Thận

```
Sau khi cwnd ≥ ssthresh:
→ Chuyển từ exponential → LINEAR growth
→ Mỗi RTT: cwnd += 1 MSS (thay vì ×2)
→ "Thăm dò" bandwidth khả dụng CẨN THẬN

ssthresh (Slow Start Threshold):
→ Ban đầu: rất lớn (65,535 bytes)
→ Khi packet loss: ssthresh = cwnd / 2
→ Là "ký ức" về điểm tắc nghẽn trước đó
```

### 5.3 Fast Retransmit & Fast Recovery

```
╔═══════════════════════════════════════════════════════════════╗
║   PHẢN ỨNG KHI PACKET LOSS                                   ║
╠═══════════════════════════════════════════════════════════════╣
║                                                               ║
║  Có 2 loại "tín hiệu" packet loss:                          ║
║                                                               ║
║  1) TIMEOUT (RTO expires) — nghiêm trọng!                   ║
║     → "Mạng có thể đã chết!"                               ║
║     → ssthresh = cwnd / 2                                   ║
║     → cwnd = 1 MSS (bắt đầu lại từ đầu!)                  ║
║     → Quay về Slow Start                                     ║
║     → Rất CHẬM để recover!                                   ║
║                                                               ║
║  2) 3 DUPLICATE ACKs — nhẹ hơn                              ║
║     → "Mất 1 packet nhưng các packet sau VẪN đến"          ║
║     → Network vẫn hoạt động!                                 ║
║     → ssthresh = cwnd / 2                                   ║
║     → cwnd = ssthresh + 3 (Fast Recovery)                   ║
║     → KHÔNG quay về Slow Start!                              ║
║     → Recovery nhanh hơn NHIỀU!                              ║
║                                                               ║
║  cwnd                                                         ║
║    │      ╱╲                                                  ║
║    │     ╱  ╲  3 DupACKs                                     ║
║    │    ╱    ╲──── cwnd/2 ─────╱╲                            ║
║    │   ╱              ╱╲     ╱  ╲                            ║
║    │  ╱              ╱  ╲   ╱                                ║
║    │ ╱              ╱    ╲ ╱                                  ║
║    │╱  Timeout!    ╱                                          ║
║    │╲             ╱                                           ║
║    │ ╲───→ cwnd=1 → Slow Start lại!                         ║
║    └──────────────────────────────── time                    ║
║                                                               ║
║  TCP Tahoe (1988):  Timeout → cwnd=1                        ║
║  TCP Reno (1990):   3 DupACK → cwnd/2 (Fast Recovery)      ║
║  TCP NewReno:       Improved recovery cho multiple losses    ║
║  TCP CUBIC (2005):  Cubic function, Linux default            ║
║  TCP BBR (2016):    Model-based, bandwidth probing          ║
║                                                               ║
╚═══════════════════════════════════════════════════════════════╝
```

### 5.4 CUBIC vs BBR — Modern Congestion Control

```
╔═══════════════════════════════════════════════════════════════╗
║   CUBIC vs BBR — CHỌN CÁI NÀO?                              ║
╠═══════════════════════════════════════════════════════════════╣
║                                                               ║
║  CUBIC (Linux default):                                      ║
║  ────────────────────                                        ║
║  → Loss-based: giảm cwnd khi packet loss                    ║
║  → Cubic function: recovery nhanh sau loss                  ║
║  → Fair với TCP Reno flows                                   ║
║  → Tốt cho hầu hết use cases                               ║
║  → VẤN ĐỀ: coi loss = congestion, nhưng WiFi/mobile       ║
║    loss KHÔNG phải congestion! → giảm tốc vô ích!          ║
║                                                               ║
║  BBR (Google, 2016):                                         ║
║  ────────────────                                            ║
║  → Model-based: đo Bottleneck Bandwidth × RT              ║
║  → KHÔNG dựa vào packet loss → tốt cho WiFi/mobile!       ║
║  → YouTube: giảm 4% rebuffering TOÀN CẦU!                  ║
║  → Giữ buffer nhỏ → latency thấp hơn                      ║
║                                                               ║
║  So sánh:                                                     ║
║  ┌──────────────┬──────────────┬──────────────────┐         ║
║  │              │ CUBIC        │ BBR              │         ║
║  ├──────────────┼──────────────┼──────────────────┤         ║
║  │ Approach     │ Loss-based   │ Model-based      │         ║
║  │ Signal       │ Packet loss  │ BW + RTT probe   │         ║
║  │ Buffer       │ Fills buffer │ Drains buffer    │         ║
║  │ Latency      │ Higher       │ Lower            │         ║
║  │ Lossy link   │ Poor (WiFi)  │ Good             │         ║
║  │ Fairness     │ Good         │ Aggressive v1*   │         ║
║  │ Adoption     │ Linux default│ Google, Akamai   │         ║
║  └──────────────┴──────────────┴──────────────────┘         ║
║                                                               ║
║  * BBRv1 có vấn đề fairness với CUBIC flows.                ║
║    BBRv2/v3 đã fix nhưng chưa mainline.                     ║
║                                                               ║
║  Khi nào dùng BBR?                                           ║
║  → Video streaming (YouTube, Netflix)                        ║
║  → CDN (Akamai, Cloudflare)                                 ║
║  → High-latency links (satellite, intercontinental)         ║
║  → Mobile/WiFi (lossy channels)                              ║
║  → Enable: sysctl net.ipv4.tcp_congestion_control=bbr       ║
║                                                               ║
╚═══════════════════════════════════════════════════════════════╝
```

---

## §6. TCP Performance Tuning — Tối Ưu Cho Production

### Kernel Parameters Quan Trọng Nhất

```
╔═══════════════════════════════════════════════════════════════╗
║   LINUX TCP TUNING — PRODUCTION CHECKLIST                    ║
╠═══════════════════════════════════════════════════════════════╣
║                                                               ║
║  ┌─────────────────────────────────┬─────────┬──────────────┐║
║  │ Parameter                       │ Default │ Recommended  │║
║  ├─────────────────────────────────┼─────────┼──────────────┤║
║  │ net.core.somaxconn              │ 128     │ 4096         │║
║  │ (Accept queue size)             │         │              │║
║  ├─────────────────────────────────┼─────────┼──────────────┤║
║  │ net.ipv4.tcp_max_syn_backlog    │ 128     │ 4096         │║
║  │ (SYN queue size)                │         │              │║
║  ├─────────────────────────────────┼─────────┼──────────────┤║
║  │ net.ipv4.tcp_tw_reuse           │ 0       │ 1            │║
║  │ (Reuse TIME_WAIT sockets)       │         │              │║
║  ├─────────────────────────────────┼─────────┼──────────────┤║
║  │ net.ipv4.tcp_fin_timeout        │ 60      │ 15-30        │║
║  │ (TIME_WAIT duration)            │         │              │║
║  ├─────────────────────────────────┼─────────┼──────────────┤║
║  │ net.ipv4.ip_local_port_range    │ 32768   │ 1024 65535   │║
║  │ (Ephemeral port range)          │ 60999   │              │║
║  ├─────────────────────────────────┼─────────┼──────────────┤║
║  │ net.ipv4.tcp_keepalive_time     │ 7200    │ 600          │║
║  │ (Keep-alive probe start, sec)   │         │              │║
║  ├─────────────────────────────────┼─────────┼──────────────┤║
║  │ net.ipv4.tcp_keepalive_intvl    │ 75      │ 30           │║
║  │ (Keep-alive probe interval)     │         │              │║
║  ├─────────────────────────────────┼─────────┼──────────────┤║
║  │ net.ipv4.tcp_keepalive_probes   │ 9       │ 5            │║
║  │ (Probes before declaring dead)  │         │              │║
║  ├─────────────────────────────────┼─────────┼──────────────┤║
║  │ net.core.rmem_max               │ 212992  │ 16777216     │║
║  │ (Max receive buffer, 16 MB)     │         │              │║
║  ├─────────────────────────────────┼─────────┼──────────────┤║
║  │ net.core.wmem_max               │ 212992  │ 16777216     │║
║  │ (Max send buffer, 16 MB)        │         │              │║
║  ├─────────────────────────────────┼─────────┼──────────────┤║
║  │ net.ipv4.tcp_syncookies         │ 1       │ 1            │║
║  │ (SYN flood protection)          │         │              │║
║  ├─────────────────────────────────┼─────────┼──────────────┤║
║  │ net.ipv4.tcp_congestion_control │ cubic   │ bbr*         │║
║  │ (* cho streaming/CDN)           │         │              │║
║  └─────────────────────────────────┴─────────┴──────────────┘║
║                                                               ║
║  Apply:                                                       ║
║  → sysctl -w net.core.somaxconn=4096                        ║
║  → Persistent: thêm vào /etc/sysctl.d/99-tcp-tuning.conf   ║
║                                                               ║
╚═══════════════════════════════════════════════════════════════╝
```

### Go HTTP Server — Production TCP Settings

```go
// Go: TCP server tuning cho production
package main

import (
    "crypto/tls"
    "fmt"
    "net"
    "net/http"
    "time"
)

func main() {
    // Custom listener với TCP tuning
    ln, err := net.Listen("tcp", ":8080")
    if err != nil {
        panic(err)
    }

    server := &http.Server{
        // ⚠️ LUÔN set timeouts! Default = 0 = KHÔNG timeout!
        // Không timeout → slow clients giữ connections FOREVER!
        ReadTimeout:       5 * time.Second,  // thời gian đọc request
        ReadHeaderTimeout: 2 * time.Second,  // thời gian đọc headers
        WriteTimeout:      10 * time.Second, // thời gian ghi response
        IdleTimeout:       120 * time.Second, // keep-alive timeout

        // Max header size (chống header bomb)
        MaxHeaderBytes: 1 << 20, // 1 MB

        // TLS config (production)
        TLSConfig: &tls.Config{
            MinVersion: tls.VersionTLS12,
            CurvePreferences: []tls.CurveID{
                tls.X25519, tls.CurveP256,
            },
            CipherSuites: []uint16{
                tls.TLS_ECDHE_RSA_WITH_AES_256_GCM_SHA384,
                tls.TLS_ECDHE_RSA_WITH_AES_128_GCM_SHA256,
            },
        },

        Handler: http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
            fmt.Fprintln(w, "Hello, TCP-tuned world!")
        }),
    }

    // Custom TCP listener với keep-alive
    tcpListener := ln.(*net.TCPListener)
    _ = tcpListener // có thể set TCP options ở đây

    fmt.Println("Server listening on :8080")
    server.Serve(tcpKeepAliveListener{tcpListener})
}

// TCP Keep-Alive listener wrapper
type tcpKeepAliveListener struct {
    *net.TCPListener
}

func (ln tcpKeepAliveListener) Accept() (net.Conn, error) {
    tc, err := ln.AcceptTCP()
    if err != nil {
        return nil, err
    }
    // Enable TCP keep-alive để phát hiện dead connections
    tc.SetKeepAlive(true)
    tc.SetKeepAlivePeriod(3 * time.Minute)
    // TCP_NODELAY cho low latency
    tc.SetNoDelay(true)
    return tc, nil
}
```

```go
// Go: HTTP Client tuning cho high-throughput
package main

import (
    "crypto/tls"
    "io"
    "net"
    "net/http"
    "time"
)

func NewProductionHTTPClient() *http.Client {
    return &http.Client{
        Timeout: 30 * time.Second, // overall request timeout

        Transport: &http.Transport{
            // Connection pooling
            MaxIdleConns:        200,               // total idle
            MaxIdleConnsPerHost: 50,                // per host
            MaxConnsPerHost:     100,               // max per host
            IdleConnTimeout:     90 * time.Second,

            // TCP tuning
            DialContext: (&net.Dialer{
                Timeout:   5 * time.Second,   // connection timeout
                KeepAlive: 30 * time.Second,  // TCP keep-alive
            }).DialContext,

            // TLS
            TLSClientConfig: &tls.Config{
                MinVersion: tls.VersionTLS12,
            },
            TLSHandshakeTimeout: 5 * time.Second,

            // HTTP/2
            ForceAttemptHTTP2: true,

            // Timeouts
            ResponseHeaderTimeout: 10 * time.Second,
            ExpectContinueTimeout: 1 * time.Second,
        },
    }
}

// ⚠️ CRITICAL: LUÔN đọc hết body + close!
func doRequest(client *http.Client, url string) error {
    resp, err := client.Get(url)
    if err != nil {
        return err
    }
    // PHẢI đọc hết body để connection có thể REUSE!
    io.Copy(io.Discard, resp.Body)
    resp.Body.Close()
    return nil
}
```

---

## §7. TCP vs UDP — Trade-off Analysis

### First Principles: Hai triết lý đối lập

```
╔═══════════════════════════════════════════════════════════════════════════╗
║   TCP vs UDP — HAI TRIẾT LÝ THIẾT KẾ                                   ║
╠═══════════════════════════════════════════════════════════════════════════╣
║                                                                           ║
║  TCP = "Thà chậm còn hơn sai"                                          ║
║  → Reliable, ordered, connection-oriented                                ║
║  → Giống gửi bưu kiện: tracking, xác nhận, bảo hiểm                  ║
║                                                                           ║
║  UDP = "Thà nhanh còn hơn đợi"                                         ║
║  → Unreliable, unordered, connectionless                                 ║
║  → Giống hét qua loa phóng thanh: nhanh nhưng có thể nghe sót        ║
║                                                                           ║
╚═══════════════════════════════════════════════════════════════════════════╝
```

### So sánh toàn diện

```
┌─────────────────────┬───────────────────┬───────────────────────┐
│ Tiêu chí            │ TCP               │ UDP                   │
├─────────────────────┼───────────────────┼───────────────────────┤
│ Connection          │ Connection-oriented│ Connectionless       │
│                     │ (handshake needed) │ (fire and forget)    │
├─────────────────────┼───────────────────┼───────────────────────┤
│ Reliability         │ ✅ Guaranteed     │ ❌ Best-effort       │
│                     │ ACK, retransmit   │ No ACK, no retransmit│
├─────────────────────┼───────────────────┼───────────────────────┤
│ Ordering            │ ✅ In-order       │ ❌ No ordering       │
│                     │ SEQ numbers       │ May arrive out of    │
│                     │                   │ order or not at all  │
├─────────────────────┼───────────────────┼───────────────────────┤
│ Header size         │ 20-60 bytes       │ 8 bytes only!        │
├─────────────────────┼───────────────────┼───────────────────────┤
│ Connection setup    │ 1.5 RTT (3-way)   │ 0 RTT!               │
├─────────────────────┼───────────────────┼───────────────────────┤
│ Throughput          │ Limited by cwnd   │ Only limited by      │
│                     │ + rwnd + loss     │ network capacity     │
├─────────────────────┼───────────────────┼───────────────────────┤
│ Head-of-line block  │ ✅ YES (problem!) │ ❌ No (advantage)    │
├─────────────────────┼───────────────────┼───────────────────────┤
│ Flow control        │ ✅ Sliding window │ ❌ None              │
├─────────────────────┼───────────────────┼───────────────────────┤
│ Congestion control  │ ✅ Built-in       │ ❌ None (dangerous!) │
├─────────────────────┼───────────────────┼───────────────────────┤
│ Broadcast/Multicast │ ❌ No             │ ✅ Yes               │
├─────────────────────┼───────────────────┼───────────────────────┤
│ State per conn      │ ~3-5 KB memory    │ 0 (stateless)        │
├─────────────────────┼───────────────────┼───────────────────────┤
│ NAT traversal       │ Difficult         │ Easier (hole punch)  │
├─────────────────────┼───────────────────┼───────────────────────┤
│ Use cases           │ HTTP, DB, Email   │ DNS, Video, Gaming   │
│                     │ File transfer     │ VoIP, IoT sensors    │
└─────────────────────┴───────────────────┴───────────────────────┘
```

### Decision Tree: Khi Nào Dùng TCP vs UDP?

```
╔═══════════════════════════════════════════════════════════════╗
║   DECISION TREE — TCP hay UDP?                                ║
╠═══════════════════════════════════════════════════════════════╣
║                                                               ║
║  Data PHẢI đến đầy đủ, đúng thứ tự?                        ║
║  ├── YES → TCP                                               ║
║  │   ├── API (REST, gRPC) → TCP                             ║
║  │   ├── Database connections → TCP                          ║
║  │   ├── File transfer → TCP                                 ║
║  │   ├── Email (SMTP) → TCP                                 ║
║  │   └── WebSocket → TCP (upgrade from HTTP)                ║
║  │                                                            ║
║  └── NO: mất vài packet CHẤP NHẬN ĐƯỢC?                    ║
║      ├── YES → UDP có thể phù hợp                          ║
║      │   ├── Cần LATENCY cực thấp?                          ║
║      │   │   ├── Online gaming → UDP + custom reliability   ║
║      │   │   └── VoIP/Video call → UDP (RTP over UDP)      ║
║      │   │                                                    ║
║      │   ├── Cần broadcast/multicast?                       ║
║      │   │   └── Service discovery → UDP multicast          ║
║      │   │                                                    ║
║      │   ├── Request nhỏ, response nhỏ?                    ║
║      │   │   └── DNS → UDP (< 512 bytes)                    ║
║      │   │       (DNS dùng TCP khi response > 512B)         ║
║      │   │                                                    ║
║      │   └── IoT/Sensors: lossy OK, battery quan trọng?    ║
║      │       └── CoAP over UDP                               ║
║      │                                                        ║
║      └── CẦN reliability + low latency?                      ║
║          └── QUIC (HTTP/3): UDP + tự implement reliability  ║
║              → "Best of both worlds" (nhưng CPU cost cao!)  ║
║                                                               ║
╚═══════════════════════════════════════════════════════════════╝
```

### QUIC — "TCP 2.0" Trên UDP

```
╔═══════════════════════════════════════════════════════════════╗
║   TẠI SAO QUIC CHẠY TRÊN UDP THAY VÌ TẠO PROTOCOL MỚI?   ║
╠═══════════════════════════════════════════════════════════════╣
║                                                               ║
║  WHY 1: "Tại sao không tạo transport protocol mới?"        ║
║  → Middleboxes (firewall, NAT, proxy) chỉ hiểu TCP + UDP! ║
║  → Protocol mới → bị DROP bởi hàng triệu thiết bị!       ║
║                                                               ║
║  WHY 2: "Tại sao không fix TCP?"                            ║
║  → TCP implement trong KERNEL. Thay đổi kernel = 5-15 năm  ║
║    để deploy trên toàn bộ internet!                         ║
║  → QUIC implement trong USERSPACE → deploy ngay = update   ║
║    app, không cần update OS!                                 ║
║                                                               ║
║  WHY 3: "QUIC giải quyết gì mà TCP không?"                 ║
║  → Head-of-line blocking: TCP 1 stream bị block → TẤT CẢ  ║
║    streams bị block. QUIC: mỗi stream independent!         ║
║  → 0-RTT: gửi data NGAY trong handshake!                   ║
║  → Connection migration: đổi WiFi → 4G KHÔNG MẤT kết nối!║
║  → Built-in TLS 1.3: không thêm RTT cho TLS!              ║
║                                                               ║
║  TCP + TLS 1.3:     3 RTT (TCP handshake + TLS)            ║
║  QUIC first conn:   1 RTT (handshake + TLS combined!)      ║
║  QUIC resumed:      0 RTT! (data trong first packet!)       ║
║                                                               ║
╚═══════════════════════════════════════════════════════════════╝
```

---

## §8. Reverse Engineering — Tự Implement TCP Concepts

### "What I cannot create, I do not understand" — Feynman

```go
// Reverse Engineering: implement TCP-like reliability trên UDP
// Mục đích: HIỂU cơ chế TCP, không phải dùng cho production!
package main

import (
    "encoding/binary"
    "fmt"
    "net"
    "sync"
    "time"
)

// TCP Header đơn giản hóa
type Segment struct {
    SeqNum  uint32 // Sequence number
    AckNum  uint32 // Acknowledgment number
    Flags   uint8  // SYN=1, ACK=2, FIN=4, DATA=8
    Payload []byte // Data
}

const (
    FlagSYN  = 1
    FlagACK  = 2
    FlagFIN  = 4
    FlagDATA = 8
)

// Encode segment thành bytes
func (s *Segment) Encode() []byte {
    buf := make([]byte, 9+len(s.Payload))
    binary.BigEndian.PutUint32(buf[0:4], s.SeqNum)
    binary.BigEndian.PutUint32(buf[4:8], s.AckNum)
    buf[8] = s.Flags
    copy(buf[9:], s.Payload)
    return buf
}

// Decode bytes thành segment
func DecodeSegment(data []byte) *Segment {
    if len(data) < 9 {
        return nil
    }
    return &Segment{
        SeqNum:  binary.BigEndian.Uint32(data[0:4]),
        AckNum:  binary.BigEndian.Uint32(data[4:8]),
        Flags:   data[8],
        Payload: data[9:],
    }
}

// ReliableSender: gửi data với ACK + retransmission
type ReliableSender struct {
    conn     *net.UDPConn
    addr     *net.UDPAddr
    seqNum   uint32
    mu       sync.Mutex
    ackChan  chan uint32
    timeout  time.Duration
    maxRetry int
}

func NewReliableSender(conn *net.UDPConn, addr *net.UDPAddr) *ReliableSender {
    rs := &ReliableSender{
        conn:     conn,
        addr:     addr,
        seqNum:   1000, // ISN (đơn giản hóa, production random!)
        ackChan:  make(chan uint32, 100),
        timeout:  500 * time.Millisecond, // RTO đơn giản
        maxRetry: 5,
    }
    go rs.listenACKs() // goroutine nhận ACKs
    return rs
}

func (rs *ReliableSender) listenACKs() {
    buf := make([]byte, 1024)
    for {
        n, _, err := rs.conn.ReadFromUDP(buf)
        if err != nil {
            return
        }
        seg := DecodeSegment(buf[:n])
        if seg != nil && seg.Flags&FlagACK != 0 {
            rs.ackChan <- seg.AckNum
        }
    }
}

// Send: gửi data đáng tin cậy (giống TCP!)
func (rs *ReliableSender) Send(data []byte) error {
    rs.mu.Lock()
    seq := rs.seqNum
    rs.seqNum += uint32(len(data))
    rs.mu.Unlock()

    seg := &Segment{
        SeqNum:  seq,
        Flags:   FlagDATA,
        Payload: data,
    }

    expectedACK := seq + uint32(len(data))

    // Retransmission loop (giống TCP timeout-based retransmit!)
    for retry := 0; retry < rs.maxRetry; retry++ {
        // Gửi segment
        rs.conn.WriteToUDP(seg.Encode(), rs.addr)
        fmt.Printf("[SEND] SEQ=%d, Len=%d, Retry=%d\n",
            seq, len(data), retry)

        // Đợi ACK với timeout
        timer := time.NewTimer(rs.timeout * time.Duration(1<<retry))
        // ↑ Exponential backoff! 500ms → 1s → 2s → 4s → 8s

        select {
        case ack := <-rs.ackChan:
            timer.Stop()
            if ack >= expectedACK {
                fmt.Printf("[ACK]  Received ACK=%d ✅\n", ack)
                return nil // thành công!
            }
        case <-timer.C:
            fmt.Printf("[TIMEOUT] Retransmitting SEQ=%d...\n", seq)
            // Timeout → retransmit! (giống TCP RTO)
        }
    }
    return fmt.Errorf("max retries exceeded for SEQ=%d", seq)
}

func main() {
    fmt.Println("=== Mini TCP: Reliable delivery trên UDP ===")
    fmt.Println("Bài học: TCP phải xử lý TẤT CẢ những điều trên")
    fmt.Println("+ flow control, congestion control, ordering, ...")
    fmt.Println("→ Đó là lý do TCP phức tạp!")
}
```

### Go: TCP Socket Programming — Từ Zero

```go
// Go: raw TCP server + client — hiểu TCP ở mức socket
package main

import (
    "bufio"
    "fmt"
    "net"
    "os"
    "strings"
)

// TCP Echo Server
func startServer() {
    // 1. Tạo listening socket (LISTEN state)
    listener, err := net.Listen("tcp", ":9000")
    if err != nil {
        panic(err)
    }
    defer listener.Close()
    fmt.Println("[SERVER] Listening on :9000 (TCP LISTEN state)")

    for {
        // 2. Accept connection (3-way handshake xảy ra ở đây!)
        // Kernel tự xử lý SYN → SYN-ACK → ACK
        // accept() chỉ lấy connection ĐÃ HOÀN THÀNH từ Accept Queue
        conn, err := listener.Accept()
        if err != nil {
            fmt.Println("[SERVER] Accept error:", err)
            continue
        }

        // Mỗi connection = 1 goroutine (giống thread-per-connection)
        go handleConnection(conn)
    }
}

func handleConnection(conn net.Conn) {
    // conn.RemoteAddr() = (client_ip:client_port)
    // conn.LocalAddr() = (server_ip:server_port)
    // Cả 4 giá trị tạo thành 4-tuple identify connection!
    fmt.Printf("[SERVER] New connection: %s → %s\n",
        conn.RemoteAddr(), conn.LocalAddr())

    defer func() {
        conn.Close() // Gửi FIN → 4-way teardown bắt đầu!
        fmt.Printf("[SERVER] Connection closed: %s\n", conn.RemoteAddr())
    }()

    scanner := bufio.NewScanner(conn)
    for scanner.Scan() {
        msg := scanner.Text()
        fmt.Printf("[SERVER] Received: %q from %s\n", msg, conn.RemoteAddr())

        // Echo back (data gửi qua TCP stream)
        response := fmt.Sprintf("Echo: %s\n", strings.ToUpper(msg))
        conn.Write([]byte(response))
        // Write() → kernel buffer → TCP segment → IP packet → network
        // TCP đảm bảo response ĐẾN NƠI và ĐÚNG THỨ TỰ!
    }
}

// TCP Client
func startClient() {
    // net.Dial → kernel thực hiện 3-way handshake:
    // SYN → SYN-ACK → ACK → connection ESTABLISHED!
    conn, err := net.Dial("tcp", "localhost:9000")
    if err != nil {
        panic(err) // "connection refused" = server not listening!
    }
    defer conn.Close()

    fmt.Printf("[CLIENT] Connected: %s → %s\n",
        conn.LocalAddr(), conn.RemoteAddr())
    // LocalAddr: ephemeral port (49152-65535)
    // RemoteAddr: server port (9000)

    scanner := bufio.NewScanner(os.Stdin)
    fmt.Print("Type message (Ctrl+C to quit): ")
    for scanner.Scan() {
        msg := scanner.Text()
        fmt.Fprintf(conn, "%s\n", msg) // Gửi qua TCP stream

        // Đọc response
        response, _ := bufio.NewReader(conn).ReadString('\n')
        fmt.Printf("[CLIENT] Response: %s", response)
        fmt.Print("Type message: ")
    }
}

func main() {
    if len(os.Args) > 1 && os.Args[1] == "client" {
        startClient()
    } else {
        startServer()
    }
}
// Run: go run main.go         (server)
//      go run main.go client  (client, in another terminal)
```

---

## §9. Trade-off Analysis Tổng Hợp

### Tam Giác Trade-off của TCP

```
╔═══════════════════════════════════════════════════════════════╗
║   TCP TRADE-OFF TRIANGLE                                      ║
╠═══════════════════════════════════════════════════════════════╣
║                                                               ║
║            Reliability                                        ║
║               ╱╲                                              ║
║              ╱  ╲     TCP = Reliability + Throughput          ║
║             ╱    ╲    (sacrifice Latency)                     ║
║            ╱  TCP ╲                                           ║
║           ╱        ╲   UDP = Latency + Throughput             ║
║          ╱──────────╲  (sacrifice Reliability)                ║
║         ╱            ╲                                        ║
║        ╱   QUIC = All  ╲  QUIC = Reliability + Latency       ║
║       ╱   (CPU cost!)   ╲ (sacrifice CPU/complexity)         ║
║      ╱                    ╲                                   ║
║   Latency ──────────────── Throughput                        ║
║                                                               ║
║  "Không có free lunch — mọi cải thiện đều có cái giá."     ║
║                                                               ║
╚═══════════════════════════════════════════════════════════════╝
```

### Matrix: TCP Features vs Costs

```
┌──────────────────────┬──────────────────┬──────────────────────┐
│ Feature              │ Benefit          │ Cost                 │
├──────────────────────┼──────────────────┼──────────────────────┤
│ 3-Way Handshake      │ Reliable setup   │ +1.5 RTT latency    │
│                      │ ISN sync         │ SYN flood vuln      │
│                      │                  │ Memory cho state    │
├──────────────────────┼──────────────────┼──────────────────────┤
│ SEQ/ACK              │ Ordered delivery │ 8 bytes/packet       │
│                      │ Loss detection   │ Cumulative ACK limit │
├──────────────────────┼──────────────────┼──────────────────────┤
│ Retransmission       │ No data loss     │ Increased latency    │
│                      │                  │ Bandwidth waste      │
│                      │                  │ (retransmit =        │
│                      │                  │ duplicate traffic!)  │
├──────────────────────┼──────────────────┼──────────────────────┤
│ Flow Control         │ Prevent overflow │ Throughput limited   │
│                      │                  │ by slow receiver     │
├──────────────────────┼──────────────────┼──────────────────────┤
│ Congestion Control   │ Network stable   │ Slow start penalty   │
│                      │                  │ Underutilization     │
│                      │                  │ after loss           │
├──────────────────────┼──────────────────┼──────────────────────┤
│ Head-of-line block   │ In-order delivery│ 1 lost packet blocks │
│                      │                  │ ALL subsequent data! │
├──────────────────────┼──────────────────┼──────────────────────┤
│ Keep-alive           │ Detect dead conn │ Extra packets        │
│                      │ Maintain NAT     │ (every 2 hours       │
│                      │                  │ default!)            │
├──────────────────────┼──────────────────┼──────────────────────┤
│ Connection Pooling   │ Avoid handshake  │ Memory per idle conn │
│                      │ Reuse warm conns │ Pool management      │
│                      │ Skip slow start! │ complexity           │
├──────────────────────┼──────────────────┼──────────────────────┤
│ TIME_WAIT            │ Prevent old      │ Port exhaustion      │
│                      │ packet confusion │ 60-120s per close    │
│                      │ Reliable close   │ Memory per socket    │
└──────────────────────┴──────────────────┴──────────────────────┘
```

### Kịch Bản Thất Bại: "Khi Nào TCP Thất Bại Hoàn Toàn?"

```
╔═══════════════════════════════════════════════════════════════╗
║   TCP FAILURE SCENARIOS                                       ║
╠═══════════════════════════════════════════════════════════════╣
║                                                               ║
║  1. HIGH PACKET LOSS NETWORK (>5%):                          ║
║     → Retransmission loop → throughput gần 0!               ║
║     → Congestion control giảm cwnd liên tục                 ║
║     → Ví dụ: satellite link, mobile in elevator              ║
║     → Fix: BBR (model-based, không dựa trên loss)           ║
║                                                               ║
║  2. HIGH LATENCY + SHORT REQUESTS:                           ║
║     → Handshake 1.5 RTT chiếm phần lớn thời gian!         ║
║     → RTT=300ms (xuyên đại dương) → 450ms handshake!      ║
║     → + TLS: 750ms trước khi gửi byte đầu tiên!           ║
║     → Fix: QUIC 0-RTT, TFO, connection pooling             ║
║                                                               ║
║  3. MULTIPLEXED STREAMS (HTTP/2 over TCP):                   ║
║     → 1 packet loss → block TẤT CẢ streams!               ║
║     → Head-of-line blocking ở TCP level!                    ║
║     → Paradox: HTTP/2 có thể CHẬM HƠN HTTP/1.1 khi loss!  ║
║     → Fix: QUIC (independent streams)                       ║
║                                                               ║
║  4. MASSIVE SHORT CONNECTIONS (>50K/sec):                    ║
║     → TIME_WAIT explosion → port exhaustion                 ║
║     → SYN queue overflow → connection refused               ║
║     → Fix: connection pooling, keep-alive, tw_reuse         ║
║                                                               ║
║  5. REAL-TIME REQUIREMENTS (<10ms):                          ║
║     → TCP retransmission = unacceptable delay!              ║
║     → Packet loss + retransmit = 200ms+ spike!              ║
║     → Gaming, trading, VoIP: old data = useless data!      ║
║     → Fix: UDP + application-level logic                    ║
║                                                               ║
║  6. NETWORK CHANGE (WiFi → 4G):                             ║
║     → TCP connection = (src_ip, src_port, dst_ip, dst_port)║
║     → IP thay đổi → connection DIE!                        ║
║     → Fix: QUIC connection ID (không dựa vào IP!)          ║
║                                                               ║
╚═══════════════════════════════════════════════════════════════╝
```

---

## §10. Debug TCP — Reverse Engineering Network Issues

### Practical Diagnostic Commands

```bash
# ═══════════════════════════════════════════════════
# TCP CONNECTION ANALYSIS
# ═══════════════════════════════════════════════════

# Connection state breakdown
ss -tan | awk '{print $1}' | sort | uniq -c | sort -rn
# → Healthy: mostly ESTAB, few TIME-WAIT
# → Problem: many CLOSE-WAIT (leak!), SYN-RECV (attack!)

# Per-destination connection count
ss -tn | awk '{print $5}' | sort | uniq -c | sort -rn | head -10
# → Which backend has most connections?

# TCP retransmission rate
cat /proc/net/snmp | grep Tcp
# → RetransSegs / OutSegs × 100 = loss%
# → > 1% = network problem!

# TCP memory usage
cat /proc/net/sockstat
# → TCP: inuse X orphan Y tw Z alloc W mem M
# → "mem" = pages used by TCP buffers

# Connection timing (per connection RTT)
ss -ti dst :443 | head -20
# → rtt:XX/YYms → current RTT / RTT variance
# → cwnd:XX → current congestion window
# → retrans:X/Y → retransmits / total

# ═══════════════════════════════════════════════════
# TCPDUMP — TCP PACKET ANALYSIS
# ═══════════════════════════════════════════════════

# Capture 3-way handshake
sudo tcpdump -i eth0 'tcp[tcpflags] & (tcp-syn|tcp-fin) != 0' -n
# → See SYN, SYN-ACK, FIN packets

# Capture retransmissions (requires Wireshark for analysis)
sudo tcpdump -i eth0 -w /tmp/capture.pcap host api.example.com
# Wireshark filter: tcp.analysis.retransmission

# Show TCP window sizes
sudo tcpdump -i eth0 port 443 -n -v 2>&1 | grep -E "win [0-9]+"
# → "win 0" = zero window = receiver overwhelmed!

# Show RST packets (connection errors)
sudo tcpdump -i eth0 'tcp[tcpflags] & tcp-rst != 0' -n
# → RST = connection forcefully closed
# → Many RSTs = server rejecting, port closed, or firewall
```

### Go: TCP Health Monitor

```go
// Go: production TCP health monitor
package main

import (
    "fmt"
    "net"
    "os/exec"
    "regexp"
    "strconv"
    "strings"
    "time"
)

type TCPHealth struct {
    Established int
    TimeWait    int
    CloseWait   int
    SynRecv     int
    FinWait     int
    Listening   int
}

func checkTCPHealth() (*TCPHealth, error) {
    out, err := exec.Command("ss", "-tan").Output()
    if err != nil {
        return nil, err
    }

    h := &TCPHealth{}
    for _, line := range strings.Split(string(out), "\n") {
        fields := strings.Fields(line)
        if len(fields) == 0 {
            continue
        }
        switch fields[0] {
        case "ESTAB":
            h.Established++
        case "TIME-WAIT":
            h.TimeWait++
        case "CLOSE-WAIT":
            h.CloseWait++
        case "SYN-RECV":
            h.SynRecv++
        case "FIN-WAIT-1", "FIN-WAIT-2":
            h.FinWait++
        case "LISTEN":
            h.Listening++
        }
    }
    return h, nil
}

func getRetransmitRate() (float64, error) {
    out, err := exec.Command("cat", "/proc/net/snmp").Output()
    if err != nil {
        return 0, err
    }

    lines := strings.Split(string(out), "\n")
    re := regexp.MustCompile(`\d+`)
    for i, line := range lines {
        if strings.HasPrefix(line, "Tcp:") && i > 0 {
            prev := lines[i-1] // header line
            if strings.HasPrefix(prev, "Tcp:") {
                continue
            }
            nums := re.FindAllString(line, -1)
            if len(nums) >= 12 {
                outSegs, _ := strconv.ParseFloat(nums[10], 64)
                retrans, _ := strconv.ParseFloat(nums[11], 64)
                if outSegs > 0 {
                    return (retrans / outSegs) * 100, nil
                }
            }
        }
    }
    return 0, nil
}

func main() {
    fmt.Println("=== TCP Health Monitor ===")

    health, err := checkTCPHealth()
    if err != nil {
        fmt.Printf("Error: %v\n", err)
        return
    }

    fmt.Printf("ESTABLISHED:  %d\n", health.Established)
    fmt.Printf("TIME_WAIT:    %d", health.TimeWait)
    if health.TimeWait > 10000 {
        fmt.Print(" ⚠️ HIGH! Consider connection pooling")
    }
    fmt.Println()

    fmt.Printf("CLOSE_WAIT:   %d", health.CloseWait)
    if health.CloseWait > 100 {
        fmt.Print(" 🚨 LEAK! App not closing connections!")
    }
    fmt.Println()

    fmt.Printf("SYN_RECV:     %d", health.SynRecv)
    if health.SynRecv > 500 {
        fmt.Print(" 🚨 Possible SYN flood attack!")
    }
    fmt.Println()

    // Thresholds
    fmt.Println("\n=== Alerting Thresholds ===")
    fmt.Println("TIME_WAIT > 10,000:  ⚠️  Warning")
    fmt.Println("TIME_WAIT > 30,000:  🚨 Critical")
    fmt.Println("CLOSE_WAIT > 100:    🚨 Bug! Resource leak")
    fmt.Println("SYN_RECV > 500:      🚨 SYN Flood attack")
    fmt.Println("Retransmit > 1%:     ⚠️  Network issue")
    fmt.Println("Retransmit > 5%:     🚨 Critical network")
}
```

---

## Tổng Kết — TCP Cheat Sheet

```
╔═══════════════════════════════════════════════════════════════════════════╗
║   TCP CHEAT SHEET — EVERYTHING A BACKEND ENGINEER NEEDS                  ║
╠═══════════════════════════════════════════════════════════════════════════╣
║                                                                           ║
║  CORE CONCEPTS:                                                          ║
║  → Connection-oriented, reliable, ordered, full-duplex                   ║
║  → Built on unreliable IP layer (end-to-end principle!)                 ║
║  → 4-tuple: (src_ip, src_port, dst_ip, dst_port)                       ║
║                                                                           ║
║  CONNECTION:                                                              ║
║  → Open:  SYN → SYN-ACK → ACK (1.5 RTT)                              ║
║  → Close: FIN → ACK → FIN → ACK (2 RTT) + TIME_WAIT                  ║
║  → TIME_WAIT: 60s default, cause of port exhaustion                     ║
║  → CLOSE_WAIT: BUG! App không close connection!                        ║
║                                                                           ║
║  RELIABILITY:                                                             ║
║  → SEQ/ACK: byte-level ordering                                         ║
║  → Retransmit: timeout (RTO) + 3 DupACKs (fast retransmit)             ║
║  → SACK: selective ACK → chỉ retransmit đoạn mất                     ║
║  → Checksum: detect corruption (nhưng KHÔNG fix!)                       ║
║                                                                           ║
║  FLOW CONTROL:                                                            ║
║  → Sliding window: receiver nói "tôi còn chỗ cho X bytes"             ║
║  → Zero window: receiver buffer đầy → sender DỪNG!                     ║
║  → Window scaling: option trong SYN, nhân đến 1 GB                     ║
║                                                                           ║
║  CONGESTION CONTROL:                                                      ║
║  → Slow start: cwnd ×2 mỗi RTT (exponential)                          ║
║  → Congestion avoidance: cwnd +1 mỗi RTT (linear)                     ║
║  → Loss → cwnd giảm: timeout = cwnd=1, 3DupACK = cwnd/2              ║
║  → CUBIC (Linux default) vs BBR (Google, model-based)                   ║
║                                                                           ║
║  PRODUCTION:                                                              ║
║  → LUÔN set timeouts (Read, Write, Idle)                                ║
║  → LUÔN dùng connection pooling                                          ║
║  → LUÔN close resp.Body (sau khi đọc hết!)                             ║
║  → TCP_NODELAY=true cho low-latency apps                                ║
║  → Tune: somaxconn, syn_backlog, tw_reuse, port range                  ║
║  → Monitor: ESTAB, TIME_WAIT, CLOSE_WAIT, retransmit rate              ║
║                                                                           ║
║  DEBUG:                                                                   ║
║  → ss -tan: connection states                                            ║
║  → ss -ti: per-connection RTT, cwnd, retransmits                       ║
║  → tcpdump / Wireshark: packet-level analysis                           ║
║  → netstat -s | grep retransmit: loss rate                              ║
║                                                                           ║
║  INTERVIEW QUESTIONS:                                                     ║
║  → "Tại sao cần 3-way handshake? 2 bước không đủ?"                   ║
║  → "TIME_WAIT giải quyết vấn đề gì? Hậu quả?"                       ║
║  → "Head-of-line blocking là gì? QUIC fix như thế nào?"               ║
║  → "Slow start ảnh hưởng performance thế nào?"                        ║
║  → "TCP_NODELAY khi nào bật/tắt?"                                      ║
║  → "CLOSE_WAIT trong ss output nghĩa là gì?"                          ║
║  → "BBR khác CUBIC ở điểm nào?"                                       ║
║                                                                           ║
╚═══════════════════════════════════════════════════════════════════════════╝
```

---

## Tài Liệu Tham Khảo

```
[1] RFC 793 — Transmission Control Protocol (Original, 1981)
    https://datatracker.ietf.org/doc/html/rfc793

[2] RFC 7323 — TCP Extensions for High Performance (Window Scaling, Timestamps)
    https://datatracker.ietf.org/doc/html/rfc7323

[3] RFC 2018 — TCP Selective Acknowledgment Options (SACK)
    https://datatracker.ietf.org/doc/html/rfc2018

[4] TCP Congestion Control — Van Jacobson (1988)
    https://ee.lbl.gov/papers/congavoid.pdf

[5] BBR: Congestion-Based Congestion Control — Google (2016)
    https://queue.acm.org/detail.cfm?id=3022184

[6] QUIC: A UDP-Based Multiplexed and Secure Transport
    https://datatracker.ietf.org/doc/html/rfc9000

[7] "TCP/IP Illustrated, Volume 1" — W. Richard Stevens
    → Sách KINH ĐIỂN về TCP/IP, phải đọc cho Senior!

[8] "Computer Networking: A Top-Down Approach" — Kurose & Ross
    → Textbook chuẩn, giải thích TCP rất rõ ràng

[9] Linux TCP Tuning Guide:
    https://www.kernel.org/doc/html/latest/networking/ip-sysctl.html

[10] Go net/http Transport Source Code:
     https://pkg.go.dev/net/http#Transport
     → Đọc source code để hiểu connection pooling trong Go!
```
